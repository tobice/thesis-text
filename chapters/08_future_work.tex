\chapter{Future work}
\label{chap:future-work}

There is lots of space for possible improvements of our \emph{application generator}. In this chapter, we will explore a couple of areas and explain what could be done better in those areas.

\section{Separating from LinkedPipies Visualization}

Our \emph{application generator} is integrated into the LinkedPipes Visualization. We justified this decision in Section \ref{sec:proposal:features} and as we suggested, this move did save us quite a lot of work. On the other hand, it led to certain schizophrenic situations. For example, whereas our \emph{application generator} contains a user layer (Subsection \ref{sec:implementation:overview:users}), LinkedPipes Visualization does not, but they do share the underlying instance of LDVM implementation. The consequence is that only an authenticated administrator is allowed to register a new \emph{visualizer} to our \emph{application generator} but literary anyone can use the LinkedPipes Visualization user interface to start uploading arbitrary LDVM components (an attacker could for example upload an extensive number of LDVM components which would slow down the \emph{discovery algorithm}, making it unusable).

Unfortunately, at this moment we cannot just turn off the LinkedPipes Visualization user interface as some of its functionality (specifically uploading new LDVM components, see Subsection \ref{sec:implementation:integrating-visualizer:ldvm}) is still required by our \emph{application generator}. Therefore, the first step would have be to implement the missing features to the \emph{application generator}, making it completely independent on LinkedPipes Visualization user interface.

Eventually, we need to come up with a strategy for separating these two tools. One way would be to make the \emph{application generator} the default user interface over the underlying LDVM implementation and definitely remove the current default one. This remains open. But as we explained in Section \ref{sec:implementation:general-architecture}, we made sure to keep the \emph{application generator} code as separated as possible which should simplify any potential future steps. 

\section{Platform features}

The \emph{platform} contains all the essential features but many of them are in a rather \emph{proof-of-concept} state.

\begin{itemize}
\item At this moment, it is only possible to choose application name and description. With some more information (rich text description, tags, theme category, screenshot) we could significantly improve the application catalog.
\item Similarly, each data source has only a name. It would be nice to be able to add some more information (such as description, category, author). In this case, this information could be automatically extracted from the data source itself (if it was available). Using this information, we could create a richer and more convenient data source browser. 
\item Another example is user authentication. At this moment, we support either Google users or local registration (which is not even verifying the e-mail provided by the user). Adding more account providers or improving the process of local registration would make sense.
\end{itemize}

In all these cases we just named, we typically needed a fast solution to prove that it works, and when we had it, we moved on to the next more pressing issue. In this matter, the platform could be improved and extended almost endlessly.

Nevertheless, there are couple of shortcomings that actually limit the way one can work with the \emph{application generator}. 

\begin{itemize}
\item At this moment, only data sources in the form of a SPARQL endpoint are accepted. It would be very helpful if the user could upload serialized RDF data directly or provide a HTTP link to such data.
\item The LDVM \emph{discovery} algorithm (Section \ref{sec:linkedpipes:ldvm-implementation}) offers to the user a list of discovered \emph{pipelines} to choose from. The problem is when there are several \emph{pipelines} ending with the same \emph{visualizer}. The user is given no leads on which he should select. Unfortunately, the only way to figure out what a \emph{pipeline} actually produces is to run it. But we could make this decision process somehow more convenient. Firstly, the \emph{pipeline} structure could be somehow visualized to the user. By examining the components in the \emph{pipeline} the user could get a better idea of what this \emph{pipeline} does. Secondly, we could somehow utilize the \emph{visualizer features}. Typically, a \emph{pipeline} ending with a \emph{visualizer} with more \emph{features} supported is a better \emph{pipeline}. Lastly, to examine the data produced by a \emph{pipeline}, the user always has to create a new application. It would be nice if the user could somehow get a preview of how a generated application from this data set would look like.
\item Currently, re-running a \emph{pipeline} is not supported, i.e., the application is always based on the data that were produced when the \emph{pipeline} was run for the first time. It would be useful to give the user the option to re-run a \emph{pipeline} or even schedule regular \emph{pipeline} executions. If the data sources were regularly updated, the application would reflect it. It would become \emph{live}.
\item There is one exception to the previous point and that is when a \emph{pipeline} contains only a \emph{visualizer} which is directly connected to the \emph{data source}. In such a case, the \emph{pipeline} does not do anything and the original \emph{data source} is considered to be the \emph{pipeline evaluation}. This makes the application \emph{live} as suggested in the previous paragraph. Unfortunately, that has disadvantages too. If the \emph{data source} gets corrupted or disappears (remember, it is a SPARQL endpoint which the user might not have under control), the application will stop working. Therefore it would be very useful, if the user could decide whether wants to be connected directly to the \emph{data source} or to make a local copy of the data.
\end{itemize}

\section{Framework}

One of the disadvantages of current solution regarding the frontend layer is that the whole user interface is bundled into a single file. There are advantages too (as explained in Section \ref{sec:implementation:frontend-architecture}), but the problem here is that the bundles are already fairly large and they will only grow in size as new \emph{visualizer} will get implemented. The Webpack bundler supports \emph{code splitting} which means that the whole bundle will be divided into smaller pieces that will be lazily fetched by the client side when required. That should decrease the loading times of the \emph{application generator}. Adding support for \emph{code splitting} might become a necessity once the bundle size gets past certain point.

We implemented two \emph{visualizers}: D3.js Chord Visualizer (Section \ref{sec:visualizers:chord}) and Google Maps Visualizer (Section \ref{sec:visualizers:google-maps}). They both provide a way to somehow \emph{reduce} the data set before visualizing. In the chord \emph{visualizer}, the user manually searches and selects graph nodes to be visualized. In the map \emph{visualizer}, it is possible to filter the data using categories. Both, the search and the filtering are tight to the individual \emph{visualizer}. But one could easily imagine that we would use filtering to select nodes for the chord visualization, and that we would use search to add points to the map visualization. Therefore it would make sense to separate the search and the filtering from the individual \emph{visualizers} and turn them into re-usable drop-in solutions that could be utilized when developing new \emph{visualizers}. One could easily imagine, that a \emph{visualizer} would support both of them and they would get automatically activated depending on the data characteristics (which could be expressed with LDVM component \emph{features}).

New \emph{visualizers} have to be implemented directly into the \emph{application generator} code base (Section \ref{sec:implementation:integrating-visualizer}). Thanks to the modern collaboration tools this does not present a real problem. The code base exists in a public Git repository and new \emph{visualizers} could get into the code base from \emph{forked} repositories \footnote{https://help.github.com/articles/fork-a-repo/} using \emph{pull requests} \footnote{https://help.github.com/articles/using-pull-requests/}. Nevertheless, our original intention was to make the individual \emph{visualizers} completely independent as separate projects. One would then \emph{install} new \emph{visualizers} to the \emph{application generator} from a public repository (we could utilize existing package repositories like Maven \footnote{http://search.maven.org/}). Unfortunately, we failed to deliver this feature due to a lack of time and there is a question whether the current architecture design would allow this kind of integration. But should this \emph{application generator} become a widely used tool, this feature would make a lot of sense.

\section{Visualizers}

Clearly, the more \emph{visualizers} our \emph{application generator} has, the more powerful it is. We implemented just two \emph{visualizers} to prove our concept but a large part of the future work should involve developing more new \emph{visualizers} (and in general more new LDVM components).

As explained in Section \ref{sec:system_proposal:integration}, all the \emph{visualizers} are very similar in their nature as they are very \emph{domain specific}. In that section, we mentioned that the original guidelines for this thesis suggest that the user should be able to combine together different views for different types of data. Such views should be possible to display in a selected predefined layout before publishing the app. We could actually implement a \emph{visualizer} that would support this kind of applications. Its LDVM \emph{descriptor} (Section \ref{sec:linkedpipes:ldvm-implementation}) would be very general, it would accept any kind of data. The actual analysis would be performed by the \emph{visualizer} itself and depending on the data, that it would find in the data set, it would offer to the user those simple widgets (or views) that the user could combine together and put them into the selected layout. Such a \emph{visualizer} would be probably very complicated and as it would be possible to leverage very little features of the \emph{application generator}, the question is whether it actually makes sense to implement it as a new \emph{visualizer}. Perhaps it should be rather a standalone application.

Nevertheless, there is an alternative approach. Both our \emph{visualizers} support embed mode. The D3.js Chord Visualizer makes even one extract step as it allows the user to publish each chord diagram separately. We could implement a \emph{meta-visualizer} that would allow the user to combine together applications generated by other real \emph{visualizers}. This \emph{meta-visualizer} would simply contain a grid of HTML \texttt{iframes} that would display the selected applications in embed mode. Clearly, the capabilities of such a \emph{meta-visualizer} would be fairly limited but one could achieve interesting results with it.

When describing the D3.js Chord Visualizer, we explained its limitation that it is not able to work with multiple graph instances within a single data source (Subsection \ref{sec:visualizers:chord:rgml}). The \emph{visualizer} simply expects all vertices and edges to belong to a single graph. To overcome this limitation, we would add support for multiple graph instances in a way that the individual instances would be detected by the \emph{visualizer} and the user could select which graph he intends to visualize. Unfortunately, the main reason behind this limitation is that because of the way the individual graph instances are represented in RDF, it is complicated to work with them (e.g. query vertices and edges belonging to a specific graph instance). Solving this problem would be the most challenging part.

We also briefly presented our simple solution for fulltext search through RDF data (Subsection \ref{sec:visualizers:chord:rgml}). The crucial disadvantage of our solution was that it was slow as each search required going through the whole data set (linear complexity). To get better performance, we would need to introduce some kind of indexing, either by relying on an external tool (as we briefly suggested in Subsection \ref{sec:visualizers:chord:rgml}) or by implementing our own. Perhaps the simplest solution would be to load the graph data into the H2 database (which is already available) and utilize its search engine. A more thorough analysis would be required.