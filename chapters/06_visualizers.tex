\chapter{Visualizers}

To show the capabilities or our designed \emph{framework} and \emph{platform}, we decided to implement two concrete visualizers: D3.js Chord Visualizer and Google Maps Visualizer.

\section{D3.js Chord Visualizer}

\section{Google Maps Visualizer}

Google Maps Visualizer focuses on visualizing geospatial information. It shows RDF resources containing GPS coordinates on a map in a form of markers. If the data set supports it, it allows the user to filter the resources.

This \emph{visualizer} was already implemented in LinkedPipes Visualization, so we were able to re-use the LDVM \emph{visualizer component} definition and also all the backend code responsible for extracting RDF data from the \emph{pipeline evaluation}. We only had to implement the frontend part, specifically the \emph{configurator} and \emph{application} interfaces.

For these reasons, this chapter will be rather short and it will not go into technical details. Instead, we will rather focus on the comparison between the original \emph{visualizer}, which is part of LinkedPipes Visualization, and our own implementation that utilizes the capabilities of the \emph{application generator}. 

\subsection{Sample data set}

We will demonstrate the capabilities of this \emph{visualizer} using only a single data set, \textbf{Registry of business subjects in Czech Republic} [cite and use the real name]. As the name suggests, this data set contains business subjects. Each business subject has GPS coordinates of its residence. These entities will be visualized on the map.

Each business subject is put into two categories. The \emph{primary category} and the \emph{secondary category}. The data set contains list of available categories. The user will be allowed to filter the business subjects using these categories.

\subsection{Filtering}

Filtering is an essential part of this \emph{visualizer}. It works similarly to what the reader might be used to for example from browsing products in e-shops. Just for now, let us say that the data set does not contain geospatial entities but rather laptops. A laptop has properties like brand, screen size or operating system. Each of these properties defines a \emph{filter} (e.g. brand) with a list of available \emph{values} (e.g. Asus, Dell, Apple etc). The user can select an arbitrary number of \emph{values} for each \emph{filter} to create filtering criteria. For a laptop to be included in the result set, it has to match all the criteria (conjunction). For a laptop to match a criterion, its property \emph{value} corresponding to the criterion \emph{filter} must be one of the \emph{values} selected by the user (disjunction). For example, by selecting Asus and Dell as the brand, 15 inches as the screen size and Windows 10 as the operating system, the user will get all 15-inch laptops with Windows 10 manufactured either by Asus or Dell.

If the user selects all \emph{values} for a \emph{filter}, it is just as if the \emph{filter} was not there at all. It has no impact on the result set. On the other hand, if the user selects no \emph{values} for a \emph{filter}, the results set is always empty (no laptops can meet the criteria).

Available \emph{filters} and their \emph{values} has to be explicitly defined in the data set. In our sample data set, as already mentioned, those are the \emph{primary category} and \emph{secondary category}.

\subsection{Configurator and application user interface}

\emph{Configurator} and \emph{application} interfaces are very similar. Both of them feature a map and a sidebar on the left with \emph{filters}. The key difference is that in the \emph{configurator} interface, the \emph{filters} can be displayed in two modes: configuration and preview. The \emph{application} interface shows the \emph{filters} always in the same way which corresponds to the preview mode.

The idea is that by configuring the \emph{filters} the user can significantly affect the shape of the published application. Here are some examples.

\begin{itemize}
\item A \emph{filter} can be \textbf{disabled}. A disabled \emph{filter} is interpreted as if all its \emph{values} have been selected, i.e., it has no impact on the selected output. This filter is completely hidden in the published application.
\item A \emph{value} can be \textbf{enforce}. That means that it is always selected.
\item A \emph{value} can be \textbf{disabled}. That means that it cannot be selected. This \emph{value} is completely hidden in the published application.
\item A \emph{filter} can be switched between \textbf{checkbox} mode and \textbf{radio} mode. In checkbox mode, an arbitrary number of \emph{filter} \emph{values} can be selected. In radio mode, only one \emph{value} can be selected. The mode names correspond to the appropriate form controls.

\end{itemize}
Thanks to the enforcing and disabling of certain \emph{values}, it is possible to create default filters that are always applied. That essentially means that the published application can be based just on a subset of the input data. If we go back to our example with laptops, one could generate a browser of Dell laptops filterable by screen size. To achieve that, one would have to disable the operating system \emph{filter}, enforce the Dell \emph{value} and disable all other \emph{values} for the brand \emph{filter}.

By either fixing or disabling all \emph{filters} and \emph{values}, it is actually possible to generate a completely static application which might also make sense in certain situations. Moreover, It is possible to disable the sidebar with \emph{filters} completely which reduces the published application just to a static map with pre-selected markers.

Besides the filter configuration, the \emph{configurator} interface also allows the user to fix the default map position and zoom level. Naturally, it also implements the available universal features, like multi language support and custom labels editor (e.g. it is possible to rename \emph{filters}  and their \emph{values}).

% TODO: marker infowindows/tooltips

\subsection{Advantages over LinkedPipes Visualization}

The reader might be wondering why we presented a sample data set but then we used a completely different example to explain how the filtering works. The reason is that the presented data set is if not actually broken then at least very confusing (its quality is a little poor). That does not make it very suitable for explaining principles, but it makes it perfect for demonstrating the abilities of our \emph{visualizer}.

As explained, each business subject has a \emph{primary category} and a \emph{secondary category}. Those are two properties that would both make up one \emph{filter} each. Since the data is in RDF, each property is actually an RDF resource with a unique URI. The problem here is that they both have the same label and they both contain exactly the same \emph{values} which means that they will both look exactly the same to the user. The label can be approximately translated as \textit{"Businesses as defined by the 1st attachment of the integrated prevention law"}.

If we go back to the example of the e-shop selling laptops, there is one big assumption: We assume that the user is at least to some extent familiar with the nature of the product. E.g. he knows what the brand or the screen size is. Therefore we assume that he would intuitively understand what happens if he selects in the filters the brand Dell and the screen size 15 inches. In case of our data set, however, not only might the user have no idea what \textit{"Businesses as defined by the 1st attachment of the integrated prevention law"} are in the first place, but also the fact that this property is there twice would confuse him even more. 

It is important to say that this is exactly what the LinkedPipes Visualization visualizer would show. Two identical \emph{filters} with confusing names and identical \emph{values}. We can hardly expect any intuition from the user here. Plus the list of \emph{values} is fairly long and because of the way it is displayed, the user might not realize that there are actually two \emph{filters}. That might cause another problem: if the user is not aware of the second \emph{filter} and selects no \emph{values} for it, he will always get an empty result set.

Interestingly enough, the current implementation in LinkedPipes Visualization does not suffer from this problem but only by a sheer coincidence. Firstly, even though each business subject is put into two categories (\emph{primary} and \emph{secondary}), they are always the two same categories, i.e., both the \emph{primary} and the \emph{secondary category} points to the same RDF resource with the same URI. Secondly, there is a bug in the  user interface implementation of filters in LinkedPipes Visualization causing that if the user selects a \emph{value} in the \emph{primary category} \emph{filter}, this \emph{value} (identified by a URI) gets also automatically selected in the \emph{secondary category} \emph{filter}.

In the example with laptops this would mean that each laptops would have two brands which would however be always the same (e.g. a laptop would have the "primary" brand Dell and also the "secondary" brand Dell). To filter Dell laptops, we would need to specifically select Dell in both brand \emph{filters}. Because of the UI bug, this would be done automatically for us.

The reader might object that this behavior in the UI is not a bug but is rather intentional as it follows the structure of the data. Let us imagine that a laptop has two new properties. A chassis color and a keyboard color. They would correspond to two new \emph{filters} with exactly the same \emph{values} (a list of several predefined colors). Clearly, we want to select the colors independently. Selecting red for the chassis should not automatically mean selecting red for the keyboard. Note that structure of this example is identical to our data set. The only difference is that our \emph{primary category} and \emph{secondary category} both have the same label, so they appear as identical. But they are not. Their URIs are different and that is what matters.

To sum it up: a visualization of this data set generated with LinkedPipes Visualization would expose all these flaws to any end user that would come across this visualization. This makes the visualization not very user friendly. On the other hand, in our \emph{application generator} we can utilize the configuration phase to fix these issues and deliver much better user experience (not to mention that our implementation does not suffer from the aforementioned bug). Specifically, we could undergo the following steps:

\begin{itemize}
\item \textbf{Rename the \emph{filters}.} Using the custom labels editor we could provide better and more explanatory names to the \emph{filters} so that the user would get a better idea of their behavior. Just using "Primary category" and "Secondary category" as names would probably improve the overall experience. The original name, \textit{"Businesses as defined by the 1st attachment of the integrated prevention law"}, rather just explains what the \emph{values} are and this information could go to the application description.
\item \textbf{Disable one of the \emph{filters}.} As in this data set both categories are always the same, disabling one of the filters will not cause the visualization to lose any information or functionality and it will only improve the experience.
\item \textbf{Reduce the data set}. Even if one of the \emph{filters} is disabled, there is still more than 60 \emph{values} to choose from. Perhaps we could instead of one big application generate multiple smaller applications where each would utilize default filters to visualize only a specific subset of the data set.
\end{itemize}

Using our \emph{application generator}, we were able to take a data set of poor quality and turn it into a useful and user-friendly application. Which is something that would not be possible with LinkedPipes Visualization.

One last remark. The \emph{configurator interface} does not shield the user from these data set related problems. The main advantage is that only the user that generates the application needs to deal with these issues. Once the application is properly generated, it is ready to be comfortably consumed by a way broader audience. In LinkedPipes Visualization, on the other hand, everybody gets the raw visualization and has to make his own sense out of the data.
